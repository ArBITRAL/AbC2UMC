Class System with niceparallelism is
Signals:
	allowsend(i:int);
        broadcast(tgt,msg,j:int);
	start(inputids,inputwealth,inputbody,inputpe,inputph,inputeyes,inputhairs,inputpw,inputpb);
Vars:
	RANDOMQUEUE;
	receiving:bool := false;
	pc :int[];
	bound : obj[];
	my;
	table:int[];
	total:int :=0;

	-- attributes
	body;
	cb;
	ce;
	ch;
	cw;
	eyes;
	gender;
	hair;
	id;
	level;
	msgqueue;
	partner;
	pb;
	pe;
	ph;
	pw;
	wealth;
State Top Defers allowsend(i)
Transitions:

init -> SYS { start(inputids,inputwealth,inputbody,inputpe,inputph,inputeyes,inputhairs,inputpw,inputpb)/
    id :=inputids;
    wealth :=inputwealth;
    body:=inputbody;
    pe := inputpe;
    ph := inputph;
    eyes:= inputeyes;
    hair:= inputhairs;
    pw:=inputpw;
    pb :=inputpb;
  	table[0][0][0][0] := 4;
  	table[0][0][0][1] := 3;
  	table[0][0][1][0] := 2;
  	table[0][0][1][1] := 1;

  	table[0][1][0][0] := 3;
  	table[0][1][0][1] := 4;
  	table[0][1][1][0] := 1;
  	table[0][1][1][1] := 2;

  	table[1][0][0][0] := 2;
  	table[1][0][0][1] := 1;
  	table[1][0][1][0] := 4;
  	table[1][0][1][1] := 3;

  	table[1][1][0][0] := 1;
  	table[1][1][0][1] := 2;
  	table[1][1][1][0] := 3;
  	table[1][1][1][1] := 4;

	for i in 0..pc.length-1 {
		self.allowsend(i);
	}}


 ---------- COMPONENT TEMPLATE M ------------




 ---------- COMPONENT TEMPLATE W ------------


---------- COMPONENT C0 ------------
----- Receive -----
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[tgt[0] = 1 and (msg[0] = yes) and pc[0][0] = 1]/
	OUT.received(id[0],msg[0],msg[1]);
	bound[0][0] = msg;
	pc[0][0] = 2;
}

 ----- Receive -----
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[tgt[0] = 1 and (msg[0] = yes) and pc[0][0] = 2]/
	msgqueue[0] := msgqueue[0]+[bound[0][0]];
	OUT.received(id[0],msg[0],msg[1]);
	bound[0][0] = msg;
	pc[0][0] = 2;
}

 -----Empty Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and pc[0][0] = 2]/
	msgqueue[0] := msgqueue[0]+[bound[0][0]];
	self.allowsend(0);
	pc[0][0] = 1;
bound[0][0] := 0; --not used these variables
	}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and pc[0][1] = 1]/
	target:int[];
	for j in 0..pc.length-1 {
		if (eyes[j] = pe[0]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[propose,id[0],wealth[0],body[0]],0); OUT.sending(id[0],propose);
		pc[0][1] = 2;
	} else {
		pc[0][1] = 3;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 2]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 3;
	bound[0][1] = 0;
}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and (msgqueue[0] != [] and partner[0] = 0) and pc[0][1] = 3]/
	partner[0] := msgqueue[0].head[1];
	ce[0] := msgqueue[0].head[2];
	ch[0] := msgqueue[0].head[3];
	level[0] := table[pe[0]][ph[0]][ce[0]][ch[0]];
	total := total+level[0];
	msgqueue[0] := msgqueue[0].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = partner[0]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[confirm,id[0],wealth[0],body[0]],0); OUT.sending(id[0],confirm);
		pc[0][1] = 4;
	} else {
		pc[0][1] = 3;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 4]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 3;
	bound[0][1] = 0;
}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and (msgqueue[0] != [] and partner[0] != 0 and (msgqueue[0].head[3] = ph[0] and ch[0] != ph[0])) and pc[0][1] = 3]/
	ex:int := partner[0];
	partner[0] := 0;
	ce[0] := 0;
	ch[0] := 0;
	total := total-level[0];
	level[0] := 0;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = ex) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[bye,id[0]],0); OUT.sending(id[0],bye);
		pc[0][1] = 5;
	} else {
		pc[0][1] = 6;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 5]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 6;
	bound[0][1] = 0;
}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and (msgqueue[0] != [] and partner[0] = 0) and pc[0][1] = 6]/
	partner[0] := msgqueue[0].head[1];
	ce[0] := msgqueue[0].head[2];
	ch[0] := msgqueue[0].head[3];
	level[0] := table[pe[0]][ph[0]][ce[0]][ch[0]];
	total := total+level[0];
	msgqueue[0] := msgqueue[0].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = partner[0]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[confirm,id[0],wealth[0],body[0]],0); OUT.sending(id[0],confirm);
		pc[0][1] = 7;
	} else {
		pc[0][1] = 6;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 7]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 6;
	bound[0][1] = 0;
}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and (msgqueue[0] != [] and partner[0] != 0 and (msgqueue[0].head[3] != ph[0] or ch[0] = ph[0])) and pc[0][1] = 6]/
	temp:int := msgqueue[0];
	msgqueue[0] := msgqueue[0].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = temp.head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[toolate,id[0]],0); OUT.sending(id[0],toolate);
		pc[0][1] = 8;
	} else {
		pc[0][1] = 6;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 8]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 6;
	bound[0][1] = 0;
}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and (msgqueue[0] != [] and partner[0] != 0 and (ch[0] != ph[0] and msgqueue[0].head[3] = ph[0])) and pc[0][1] = 6]/
	ex:int := partner[0];
	partner[0] := 0;
	ce[0] := 0;
	ch[0] := 0;
	total := total-level[0];
	level[0] := 0;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = ex) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[bye,id[0]],0); OUT.sending(id[0],bye);
		pc[0][1] = 9;
	} else {
		pc[0][1] = 6;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 9]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 6;
	bound[0][1] = 0;
}

 ----- Receive -----
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[tgt[0] = 1 and (msgqueue[0] != []) and (msg[0] = bye and msg[1] = partner[0]) and pc[0][1] = 6]/
	ex:int := partner[0];
partner[0] := 0;
ce[0] := 0;
ch[0] := 0;
total := total-level[0];
level[0] := 0;
	OUT.received(id[0],msg[0],msg[1]);
	bound[0][1] = msg;
	pc[0][1] = 3;bound[0][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[tgt[0] = 1 and (msgqueue[0] = []) and (msg[0] = bye and msg[1] = partner[0]) and pc[0][1] = 6]/
	ex:int := partner[0];
partner[0] := 0;
ce[0] := 0;
ch[0] := 0;
total := total-level[0];
level[0] := 0;
	OUT.received(id[0],msg[0],msg[1]);
	bound[0][1] = msg;
	pc[0][1] = 1;bound[0][1]:= 0; -- not use these variables

}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and (msgqueue[0] != [] and partner[0] != 0 and (msgqueue[0].head[3] != ph[0] or ch[0] = ph[0])) and pc[0][1] = 3]/
	temp:int := msgqueue[0];
	msgqueue[0] := msgqueue[0].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = temp.head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[toolate,id[0]],0); OUT.sending(id[0],toolate);
		pc[0][1] = 12;
	} else {
		pc[0][1] = 3;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 12]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 3;
	bound[0][1] = 0;
}

 ----- Receive -----
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[tgt[0] = 1 and (msgqueue[0] != []) and (msg[0] = bye and msg[1] = partner[0]) and pc[0][1] = 3]/
	ex:int := partner[0];
partner[0] := 0;
ce[0] := 0;
ch[0] := 0;
total := total-level[0];
level[0] := 0;
	OUT.received(id[0],msg[0],msg[1]);
	bound[0][1] = msg;
	pc[0][1] = 3;bound[0][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[tgt[0] = 1 and (msgqueue[0] = []) and (msg[0] = bye and msg[1] = partner[0]) and pc[0][1] = 3]/
	ex:int := partner[0];
partner[0] := 0;
ce[0] := 0;
ch[0] := 0;
total := total-level[0];
level[0] := 0;
	OUT.received(id[0],msg[0],msg[1]);
	bound[0][1] = msg;
	pc[0][1] = 1;bound[0][1]:= 0; -- not use these variables

}

 ----- Send -----
SYS.C0.s0 -> C0.s0 {
	allowsend(i)[receiving = false and i = 0 and (msgqueue[0] = [] and partner[0] != 0 and ch[0] != ph[0]) and pc[0][1] = 3]/
	target:int[];
	for j in 0..pc.length-1 {
		if (eyes[j] = pe[0] and hair[j] = ph[0]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[propose,id[0],wealth[0],body[0]],0); OUT.sending(id[0],propose);
		pc[0][1] = 15;
	} else {
		pc[0][1] = 6;
		receiving=false;
		self.allowsend(0);
		bound[0][1] = 0;
	}
}
SYS.C0.s0 -> C0.s0 {
	broadcast(tgt,msg,j)[pc[0][1] = 15]/
	receiving=false;
	self.allowsend(0);
	pc[0][1] = 6;
	bound[0][1] = 0;
}

---------- COMPONENT C1 ------------
----- Receive -----
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[tgt[1] = 1 and (msg[0] = yes) and pc[1][0] = 1]/
	OUT.received(id[1],msg[0],msg[1]);
	bound[1][0] = msg;
	pc[1][0] = 2;
}

 ----- Receive -----
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[tgt[1] = 1 and (msg[0] = yes) and pc[1][0] = 2]/
	msgqueue[1] := msgqueue[1]+[bound[1][0]];
	OUT.received(id[1],msg[0],msg[1]);
	bound[1][0] = msg;
	pc[1][0] = 2;
}

 -----Empty Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and pc[1][0] = 2]/
	msgqueue[1] := msgqueue[1]+[bound[1][0]];
	self.allowsend(1);
	pc[1][0] = 1;
bound[1][0] := 0; --not used these variables
	}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and pc[1][1] = 1]/
	target:int[];
	for j in 0..pc.length-1 {
		if (eyes[j] = pe[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[propose,id[1],wealth[1],body[1]],1); OUT.sending(id[1],propose);
		pc[1][1] = 2;
	} else {
		pc[1][1] = 3;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 2]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 3;
	bound[1][1] = 0;
}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and (msgqueue[1] != [] and partner[1] = 0) and pc[1][1] = 3]/
	partner[1] := msgqueue[1].head[1];
	ce[1] := msgqueue[1].head[2];
	ch[1] := msgqueue[1].head[3];
	level[1] := table[pe[1]][ph[1]][ce[1]][ch[1]];
	total := total+level[1];
	msgqueue[1] := msgqueue[1].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = partner[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[confirm,id[1],wealth[1],body[1]],1); OUT.sending(id[1],confirm);
		pc[1][1] = 4;
	} else {
		pc[1][1] = 3;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 4]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 3;
	bound[1][1] = 0;
}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and (msgqueue[1] != [] and partner[1] != 0 and (msgqueue[1].head[3] = ph[1] and ch[1] != ph[1])) and pc[1][1] = 3]/
	ex:int := partner[1];
	partner[1] := 0;
	ce[1] := 0;
	ch[1] := 0;
	total := total-level[1];
	level[1] := 0;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = ex) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[bye,id[1]],1); OUT.sending(id[1],bye);
		pc[1][1] = 5;
	} else {
		pc[1][1] = 6;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 5]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 6;
	bound[1][1] = 0;
}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and (msgqueue[1] != [] and partner[1] = 0) and pc[1][1] = 6]/
	partner[1] := msgqueue[1].head[1];
	ce[1] := msgqueue[1].head[2];
	ch[1] := msgqueue[1].head[3];
	level[1] := table[pe[1]][ph[1]][ce[1]][ch[1]];
	total := total+level[1];
	msgqueue[1] := msgqueue[1].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = partner[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[confirm,id[1],wealth[1],body[1]],1); OUT.sending(id[1],confirm);
		pc[1][1] = 7;
	} else {
		pc[1][1] = 6;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 7]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 6;
	bound[1][1] = 0;
}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and (msgqueue[1] != [] and partner[1] != 0 and (msgqueue[1].head[3] != ph[1] or ch[1] = ph[1])) and pc[1][1] = 6]/
	temp:int := msgqueue[1];
	msgqueue[1] := msgqueue[1].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = temp.head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[toolate,id[1]],1); OUT.sending(id[1],toolate);
		pc[1][1] = 8;
	} else {
		pc[1][1] = 6;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 8]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 6;
	bound[1][1] = 0;
}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and (msgqueue[1] != [] and partner[1] != 0 and (ch[1] != ph[1] and msgqueue[1].head[3] = ph[1])) and pc[1][1] = 6]/
	ex:int := partner[1];
	partner[1] := 0;
	ce[1] := 0;
	ch[1] := 0;
	total := total-level[1];
	level[1] := 0;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = ex) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[bye,id[1]],1); OUT.sending(id[1],bye);
		pc[1][1] = 9;
	} else {
		pc[1][1] = 6;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 9]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 6;
	bound[1][1] = 0;
}

 ----- Receive -----
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[tgt[1] = 1 and (msgqueue[1] != []) and (msg[0] = bye and msg[1] = partner[1]) and pc[1][1] = 6]/
	ex:int := partner[1];
partner[1] := 0;
ce[1] := 0;
ch[1] := 0;
total := total-level[1];
level[1] := 0;
	OUT.received(id[1],msg[0],msg[1]);
	bound[1][1] = msg;
	pc[1][1] = 3;bound[1][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[tgt[1] = 1 and (msgqueue[1] = []) and (msg[0] = bye and msg[1] = partner[1]) and pc[1][1] = 6]/
	ex:int := partner[1];
partner[1] := 0;
ce[1] := 0;
ch[1] := 0;
total := total-level[1];
level[1] := 0;
	OUT.received(id[1],msg[0],msg[1]);
	bound[1][1] = msg;
	pc[1][1] = 1;bound[1][1]:= 0; -- not use these variables

}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and (msgqueue[1] != [] and partner[1] != 0 and (msgqueue[1].head[3] != ph[1] or ch[1] = ph[1])) and pc[1][1] = 3]/
	temp:int := msgqueue[1];
	msgqueue[1] := msgqueue[1].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = temp.head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[toolate,id[1]],1); OUT.sending(id[1],toolate);
		pc[1][1] = 12;
	} else {
		pc[1][1] = 3;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 12]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 3;
	bound[1][1] = 0;
}

 ----- Receive -----
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[tgt[1] = 1 and (msgqueue[1] != []) and (msg[0] = bye and msg[1] = partner[1]) and pc[1][1] = 3]/
	ex:int := partner[1];
partner[1] := 0;
ce[1] := 0;
ch[1] := 0;
total := total-level[1];
level[1] := 0;
	OUT.received(id[1],msg[0],msg[1]);
	bound[1][1] = msg;
	pc[1][1] = 3;bound[1][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[tgt[1] = 1 and (msgqueue[1] = []) and (msg[0] = bye and msg[1] = partner[1]) and pc[1][1] = 3]/
	ex:int := partner[1];
partner[1] := 0;
ce[1] := 0;
ch[1] := 0;
total := total-level[1];
level[1] := 0;
	OUT.received(id[1],msg[0],msg[1]);
	bound[1][1] = msg;
	pc[1][1] = 1;bound[1][1]:= 0; -- not use these variables

}

 ----- Send -----
SYS.C1.s0 -> C1.s0 {
	allowsend(i)[receiving = false and i = 1 and (msgqueue[1] = [] and partner[1] != 0 and ch[1] != ph[1]) and pc[1][1] = 3]/
	target:int[];
	for j in 0..pc.length-1 {
		if (eyes[j] = pe[1] and hair[j] = ph[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[propose,id[1],wealth[1],body[1]],1); OUT.sending(id[1],propose);
		pc[1][1] = 15;
	} else {
		pc[1][1] = 6;
		receiving=false;
		self.allowsend(1);
		bound[1][1] = 0;
	}
}
SYS.C1.s0 -> C1.s0 {
	broadcast(tgt,msg,j)[pc[1][1] = 15]/
	receiving=false;
	self.allowsend(1);
	pc[1][1] = 6;
	bound[1][1] = 0;
}

---------- COMPONENT C2 ------------
----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = propose) and pc[2][0] = 1]/
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][0] = msg;
	pc[2][0] = 2;
}

 ----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = propose) and pc[2][0] = 2]/
	msgqueue[2] := msgqueue[2]+[bound[2][0]];
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][0] = msg;
	pc[2][0] = 2;
}

 -----Empty Send -----
SYS.C2.s0 -> C2.s0 {
	allowsend(i)[receiving = false and i = 2 and pc[2][0] = 2]/
	msgqueue[2] := msgqueue[2]+[bound[2][0]];
	self.allowsend(2);
	pc[2][0] = 1;
bound[2][0] := 0; --not used these variables
	}

 ----- Send -----
SYS.C2.s0 -> C2.s0 {
	allowsend(i)[receiving = false and i = 2 and (msgqueue[2] != [] and partner[2] = 0) and pc[2][1] = 1]/
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = msgqueue[2].head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[yes,id[2],eyes[2],hair[2]],2); OUT.sending(id[2],yes);
		pc[2][1] = 2;
	} else {
		pc[2][1] = 3;
		receiving=false;
		self.allowsend(2);
		}
}
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[pc[2][1] = 2]/
	receiving=false;
	self.allowsend(2);
	pc[2][1] = 3;
}

 ----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = confirm) and pc[2][1] = 3]/
	partner[2] := msgqueue[2].head[1];
cw[2] := msgqueue[2].head[2];
cb[2] := msgqueue[2].head[3];
total := total-level[2];
level[2] := table[pw[2]][pb[2]][cw[2]][cb[2]];
total := total+level[2];
msgqueue[2] := msgqueue[2].tail;
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][1] = msg;
	pc[2][1] = 1;bound[2][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = toolate) and pc[2][1] = 3]/
	msgqueue[2] := msgqueue[2].tail;
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][1] = msg;
	pc[2][1] = 1;bound[2][1]:= 0; -- not use these variables

}

 ----- Send -----
SYS.C2.s0 -> C2.s0 {
	allowsend(i)[receiving = false and i = 2 and (msgqueue[2] != [] and partner[2] != 0 and ((cw[2] != pw[2] and msgqueue[2].head[2] = pw[2]) or (cw[2] = msgqueue[2].head[2] and cb[2] != pb[2] and msgqueue[2].head[3] = pb[2]))) and pc[2][1] = 1]/
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = msgqueue[2].head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[yes,id[2],eyes[2],hair[2]],2); OUT.sending(id[2],yes);
		pc[2][1] = 6;
	} else {
		pc[2][1] = 7;
		receiving=false;
		self.allowsend(2);
		}
}
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[pc[2][1] = 6]/
	receiving=false;
	self.allowsend(2);
	pc[2][1] = 7;
}

 ----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = confirm) and pc[2][1] = 7]/
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][1] = msg;
	pc[2][1] = 8;
}

 ----- Send -----
SYS.C2.s0 -> C2.s0 {
	allowsend(i)[receiving = false and i = 2 and pc[2][1] = 8]/
	ex:int := partner[2];
	partner[2] := msgqueue[2].head[1];
	cw[2] := msgqueue[2].head[2];
	cb[2] := msgqueue[2].head[3];
	total := total-level[2];
	level[2] := table[pw[2]][pb[2]][cw[2]][cb[2]];
	total := total+level[2];
	msgqueue[2] := msgqueue[2].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = ex) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[bye,id[2]],2); OUT.sending(id[2],bye);
		pc[2][1] = 9;
	} else {
		pc[2][1] = 1;
		receiving=false;
		self.allowsend(2);
		bound[2][1] = 0;
	}
}
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[pc[2][1] = 9]/
	receiving=false;
	self.allowsend(2);
	pc[2][1] = 1;
	bound[2][1] = 0;
}

 ----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = bye and msg[1] = msgqueue[2].head[1]) and pc[2][1] = 8]/
	temp:int := msgqueue[2];
msgqueue[2] := msgqueue[2].tail;
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][1] = msg;
	pc[2][1] = 1;bound[2][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = toolate) and pc[2][1] = 7]/
	msgqueue[2] := msgqueue[2].tail;
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][1] = msg;
	pc[2][1] = 1;bound[2][1]:= 0; -- not use these variables

}

 -----Empty Send -----
SYS.C2.s0 -> C2.s0 {
	allowsend(i)[receiving = false and i = 2 and (msgqueue[2] != [] and partner[2] != 0 and ((cw[2] = pw[2] and msgqueue[2].head[2] != pw[2]) or (cw[2] = msgqueue[2].head[2] and pb[2] != msgqueue[2].head[3] and cb[2] = pb[2]) or (cw[2] = msgqueue[2].head[2] and cb[2] = msgqueue[2].head[3]))) and pc[2][1] = 1]/
	msgqueue[2] := msgqueue[2].tail;
	self.allowsend(2);
	pc[2][1] = 1;
bound[2][1] := 0; --not used these variables
	}

 ----- Receive -----
SYS.C2.s0 -> C2.s0 {
	broadcast(tgt,msg,j)[tgt[2] = 1 and (msg[0] = bye and msg[1] = partner[2]) and pc[2][1] = 1]/
	ex:int := partner[2];
partner[2] := 0;
cw[2] := 0;
cb[2] := 0;
total := total-level[2];
level[2] := 0;
	OUT.received(id[2],msg[0],msg[1]);
	bound[2][1] = msg;
	pc[2][1] = 1;bound[2][1]:= 0; -- not use these variables

}

---------- COMPONENT C3 ------------
----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = propose) and pc[3][0] = 1]/
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][0] = msg;
	pc[3][0] = 2;
}

 ----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = propose) and pc[3][0] = 2]/
	msgqueue[3] := msgqueue[3]+[bound[3][0]];
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][0] = msg;
	pc[3][0] = 2;
}

 -----Empty Send -----
SYS.C3.s0 -> C3.s0 {
	allowsend(i)[receiving = false and i = 3 and pc[3][0] = 2]/
	msgqueue[3] := msgqueue[3]+[bound[3][0]];
	self.allowsend(3);
	pc[3][0] = 1;
bound[3][0] := 0; --not used these variables
	}

 ----- Send -----
SYS.C3.s0 -> C3.s0 {
	allowsend(i)[receiving = false and i = 3 and (msgqueue[3] != [] and partner[3] = 0) and pc[3][1] = 1]/
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = msgqueue[3].head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[yes,id[3],eyes[3],hair[3]],3); OUT.sending(id[3],yes);
		pc[3][1] = 2;
	} else {
		pc[3][1] = 3;
		receiving=false;
		self.allowsend(3);
		}
}
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[pc[3][1] = 2]/
	receiving=false;
	self.allowsend(3);
	pc[3][1] = 3;
}

 ----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = confirm) and pc[3][1] = 3]/
	partner[3] := msgqueue[3].head[1];
cw[3] := msgqueue[3].head[2];
cb[3] := msgqueue[3].head[3];
total := total-level[3];
level[3] := table[pw[3]][pb[3]][cw[3]][cb[3]];
total := total+level[3];
msgqueue[3] := msgqueue[3].tail;
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][1] = msg;
	pc[3][1] = 1;bound[3][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = toolate) and pc[3][1] = 3]/
	msgqueue[3] := msgqueue[3].tail;
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][1] = msg;
	pc[3][1] = 1;bound[3][1]:= 0; -- not use these variables

}

 ----- Send -----
SYS.C3.s0 -> C3.s0 {
	allowsend(i)[receiving = false and i = 3 and (msgqueue[3] != [] and partner[3] != 0 and ((cw[3] != pw[3] and msgqueue[3].head[2] = pw[3]) or (cw[3] = msgqueue[3].head[2] and cb[3] != pb[3] and msgqueue[3].head[3] = pb[3]))) and pc[3][1] = 1]/
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = msgqueue[3].head[1]) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[yes,id[3],eyes[3],hair[3]],3); OUT.sending(id[3],yes);
		pc[3][1] = 6;
	} else {
		pc[3][1] = 7;
		receiving=false;
		self.allowsend(3);
		}
}
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[pc[3][1] = 6]/
	receiving=false;
	self.allowsend(3);
	pc[3][1] = 7;
}

 ----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = confirm) and pc[3][1] = 7]/
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][1] = msg;
	pc[3][1] = 8;
}

 ----- Send -----
SYS.C3.s0 -> C3.s0 {
	allowsend(i)[receiving = false and i = 3 and pc[3][1] = 8]/
	ex:int := partner[3];
	partner[3] := msgqueue[3].head[1];
	cw[3] := msgqueue[3].head[2];
	cb[3] := msgqueue[3].head[3];
	total := total-level[3];
	level[3] := table[pw[3]][pb[3]][cw[3]][cb[3]];
	total := total+level[3];
	msgqueue[3] := msgqueue[3].tail;
	target:int[];
	for j in 0..pc.length-1 {
		if (id[j] = ex) then
			{target[j] := 1
	} else {target[j]:=0;}
	};
	receiving=true;
	if target.length > 0 then {
		self.broadcast(target,[bye,id[3]],3); OUT.sending(id[3],bye);
		pc[3][1] = 9;
	} else {
		pc[3][1] = 1;
		receiving=false;
		self.allowsend(3);
		bound[3][1] = 0;
	}
}
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[pc[3][1] = 9]/
	receiving=false;
	self.allowsend(3);
	pc[3][1] = 1;
	bound[3][1] = 0;
}

 ----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = bye and msg[1] = msgqueue[3].head[1]) and pc[3][1] = 8]/
	temp:int := msgqueue[3];
msgqueue[3] := msgqueue[3].tail;
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][1] = msg;
	pc[3][1] = 1;bound[3][1]:= 0; -- not use these variables

}

 ----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = toolate) and pc[3][1] = 7]/
	msgqueue[3] := msgqueue[3].tail;
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][1] = msg;
	pc[3][1] = 1;bound[3][1]:= 0; -- not use these variables

}

 -----Empty Send -----
SYS.C3.s0 -> C3.s0 {
	allowsend(i)[receiving = false and i = 3 and (msgqueue[3] != [] and partner[3] != 0 and ((cw[3] = pw[3] and msgqueue[3].head[2] != pw[3]) or (cw[3] = msgqueue[3].head[2] and pb[3] != msgqueue[3].head[3] and cb[3] = pb[3]) or (cw[3] = msgqueue[3].head[2] and cb[3] = msgqueue[3].head[3]))) and pc[3][1] = 1]/
	msgqueue[3] := msgqueue[3].tail;
	self.allowsend(3);
	pc[3][1] = 1;
bound[3][1] := 0; --not used these variables
	}

 ----- Receive -----
SYS.C3.s0 -> C3.s0 {
	broadcast(tgt,msg,j)[tgt[3] = 1 and (msg[0] = bye and msg[1] = partner[3]) and pc[3][1] = 1]/
	ex:int := partner[3];
partner[3] := 0;
cw[3] := 0;
cb[3] := 0;
total := total-level[3];
level[3] := 0;
	OUT.received(id[3],msg[0],msg[1]);
	bound[3][1] = msg;
	pc[3][1] = 1;bound[3][1]:= 0; -- not use these variables

}

end System;




------------------------------------------------------------
-- { start(inputids,inputwealth,inputbody,inputpe,inputph,inputeyes,inputhairs,inputpw,inputpb)/
------------------------------------------------------------
Class Inputgen is
Vars
  ids :=[1,2,3,4];
  wealth:= [-1,-1,-1,-1];
  body:= [-1,-1,-1,-1];
  pe:= [-1,-1,-1,-1];
  ph:= [-1,-1,-1,-1];
  eyes:= [-1,-1,-1,-1];
  hair:= [-1,-1,-1,-1];
  pw:= [-1,-1,-1,-1];
  pb:= [-1,-1,-1,-1];
  v1,v2,v3,v4;
Transitions

M0w -> M0B  {-/ wealth[0] :=0; OUT.set_m0w(0)}
M0w -> M0B  {-/ wealth[0] :=1; OUT.set_m0w(1)}
M0B -> M0pe {-/ body[0] :=0; OUT.set_m0b(0)}
M0B -> M0pe {-/ body[0] :=1; OUT.set_m0b(1)}
M0pe -> M0ph {-/ pe[0] :=0; OUT.set_m0pe(0)}
M0pe -> M0ph {-/ pe[0] :=1; OUT.set_m0pe(1)}
M0ph -> M1w {-/ ph[0] :=0; OUT.set_m0ph(0)}
M0ph -> M1w {-/ ph[0] :=1; OUT.set_m0p0(1)}

M1w -> M1B  {-/ wealth[1] :=0; OUT.set_m1w(0)}
M1w -> M1B  {-/ wealth[1] :=1; OUT.set_m1w(1)}
M1B -> M1pe {-/ body[1] :=0; OUT.set_m1b(0)}
M1B -> M1pe {-/ body[1] :=1; OUT.set_m1b(1)}
M1pe -> M1ph {-/ pe[1] :=0; OUT.set_m1pe(0)}
M1pe -> M1ph {-/ pe[1] :=1; OUT.set_m1pe(1)}
M1ph -> W2e {-/ ph[1] :=0; OUT.set_m1ph(0)}
M1ph -> W2e {-/ ph[1] :=1; OUT.set_m1p0(1)}

W2e -> W2h {-/ eyes[2] :=0; OUT.set_w2e0(0)}
W2e -> W2h {-/ eyes[2] :=1; OUT.set_w2e1(1)}
W2h -> W2pw {-/ hair[2] :=0; OUT.set_w2h(0)}
W2h -> W2pw {-/ hair[2] :=1; OUT.set_w2h(1)}
W2pw -> W2pb {-/ pw[2] :=0; OUT.set_w2pw(0)}
W2pw -> W2pb {-/ pw[2] :=1; OUT.set_w2pw(1)}
W2pb ->W3e  {-/ pb[2] :=0; OUT.set_w2pb(0)}
W2pb ->W3e  {-/ pb[2] :=1; OUT.set_w2pw(1)}

W3e -> W3h  {-/ eyes[3] :=0; OUT.set_w3e0(0)}
W3e -> W3h  {-/ eyes[3] :=1; OUT.set_w3e1(1)}
W3h -> W3pw {-/ hair[3] :=0; OUT.set_w3h(0)}
W3h -> W3pw {-/ hair[3] :=1; OUT.set_w3h(1)}
W3pw -> W3pb {-/ pw[3] :=0; OUT.set_w3pw(0)}
W3pw -> W3pb {-/ pw[3] :=1; OUT.set_w3pw(1)}
W3pb -> counting {-/ pb[3] :=0; OUT.set_w3pb(0)}
W3pb -> counting {-/ pb[3] :=1; OUT.set_w3pb(1)}

counting -> starting {-/
      v1 := wealth[0]*1000 + body[0]*100 + pe[0]*10 + ph[0];
      v2 := wealth[1]*1000 + body[1]*100 + pe[1]*10 + ph[1];
      v3 := eyes[2]*1000 + hair[2]*100 + pw[2]*10 + pb[2];
      v4 := eyes[3]*1000 + hair[3]*100 + pw[3]*10 + pb[3];
      OUT.check(v1,v2,v3,v4)}

starting -> final
          {- [(v1 <= v2) and (v3 <=v4)] /
          OO.start(ids,wealth,body,pe,ph,eyes,hair,pw,pb)}

-- E.g
-- id -> [1,2,3,4],
-- wealth -> [1,1,0,[],[],[]],
-- body -> [1,0,1,[],[],[]],
-- pe -> [1,1,1,[],[],[]],
-- ph -> [1,1,1,[],[],[]]
-- eyes -> [[],[],[],1,1,1],
-- hair -> [[],[],[],1,1,0],
-- pw -> [[],[],[],1,1,1],
-- pb -> [[],[],[],1,1,1],
end Inputgen;
Driver: Inputgen;

OO : System (id -> [1,2,3,4], gender -> [1,1,0,0], wealth -> [1,0,[],[]], pe -> [1,0,[],[]], pb -> [[],[],1,1], partner -> [0,0,0,0], hair -> [[],[],1,0], msgqueue -> [[],[],[],[]], eyes -> [[],[],1,0], pw -> [[],[],0,1], body -> [1,1,[],[]], ph -> [1,0,[],[]], pc => [[1,1],[1,1],[1,1],[1,1]], my =>[[1],[1],[1],[1]]);

Abstractions {
    State OO.partner=$v and $v[0]= $2 and OO.id[0]!=0 and OO.id[0]=$1 ->  haspartner($1,$2)
    State OO.partner=$v and $v[1]= $2 and OO.id[1]!=0 and OO.id[1]=$1 ->  haspartner($1,$2)
    State OO.partner=$v and $v[2]= $2 and OO.id[2]!=0 and OO.id[2]=$1 ->  haspartner($1,$2)
    State OO.partner=$v and $v[3]= $2 and OO.id[3]!=0 and OO.id[3]=$1 ->  haspartner($1,$2)
    Action m_decrease -> m_decreased
    Action w_decrease -> w_decreased
    Action m_increase -> m_increased
    Action w_increase -> w_increased
    Action sending($1,$2) -> send($1,$2)
    Action received($1,$2,$3) -> received($1,$2,$3)
    Action start($*) -> start($*)
}


bye, confirm, propose, toolate, yes : Token;
